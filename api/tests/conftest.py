"""
Pytest configuration and fixtures for Mobilicustos API tests.
"""

import os
import pytest
from datetime import datetime, timezone
from typing import Generator, AsyncGenerator
from unittest.mock import MagicMock, AsyncMock, patch
from uuid import uuid4

import pytest_asyncio
from fastapi.testclient import TestClient
from httpx import AsyncClient, ASGITransport

# Set test environment before importing app
os.environ["MOBILICUSTOS_ENV"] = "test"
os.environ["POSTGRES_HOST"] = "localhost"
os.environ["POSTGRES_PORT"] = "5432"
os.environ["POSTGRES_DB"] = "test"
os.environ["POSTGRES_USER"] = "test"
os.environ["POSTGRES_PASSWORD"] = "test"

# Set paths to temp directories for tests
import tempfile
_test_tmp = tempfile.mkdtemp(prefix="mobilicustos_test_")
os.environ["UPLOADS_PATH"] = _test_tmp
os.environ["REPORTS_PATH"] = _test_tmp
os.environ["FRIDA_SCRIPTS_PATH"] = _test_tmp

# Clear settings cache before importing app (in case it was already cached)
from api.config import get_settings
get_settings.cache_clear()

from api.main import app
from api.database import get_db
from api.models.database import MobileApp


# Mock result that returns None for scalar_one_or_none
class MockResult:
    """Mock SQLAlchemy result that properly handles not-found cases."""

    def __init__(self, data=None):
        self.data = data

    def scalar_one_or_none(self):
        return self.data

    def scalar(self):
        return self.data if self.data else 0

    def scalars(self):
        mock_scalars = MagicMock()
        mock_scalars.all.return_value = self.data if isinstance(self.data, list) else []
        return mock_scalars

    def all(self):
        return self.data if isinstance(self.data, list) else []


# Mock async database session
class MockAsyncSession:
    """Mock async database session for testing."""

    def __init__(self):
        self.committed = False
        self.rolled_back = False

    async def commit(self):
        self.committed = True

    async def rollback(self):
        self.rolled_back = True

    async def close(self):
        pass

    async def execute(self, *args, **kwargs):
        # Return a MockResult that returns None for single-item queries
        # This simulates "not found" for all queries in test mode
        return MockResult(None)

    async def scalar(self, *args, **kwargs):
        return None

    async def scalars(self, *args, **kwargs):
        mock = MagicMock()
        mock.all.return_value = []
        return mock

    def add(self, obj):
        # Populate fields that would normally be auto-generated by the database
        self._populate_auto_fields(obj)

    def _populate_auto_fields(self, obj):
        """Populate fields that would normally be auto-generated by the database."""
        now = datetime.now(timezone.utc)

        # Common ID fields
        if hasattr(obj, "script_id") and obj.script_id is None:
            obj.script_id = uuid4()
        if hasattr(obj, "scan_id") and obj.scan_id is None:
            obj.scan_id = uuid4()
        if hasattr(obj, "app_id") and obj.app_id is None:
            obj.app_id = f"app-{uuid4().hex[:8]}"

        # Common timestamp fields
        if hasattr(obj, "created_at") and obj.created_at is None:
            obj.created_at = now
        if hasattr(obj, "updated_at") and obj.updated_at is None:
            obj.updated_at = now
        if hasattr(obj, "upload_date") and obj.upload_date is None:
            obj.upload_date = now

        # MobileApp specific fields
        if hasattr(obj, "app_metadata") and obj.app_metadata is None:
            obj.app_metadata = {}
        if hasattr(obj, "framework_info") and obj.framework_info is None:
            obj.framework_info = {}
        if hasattr(obj, "signing_info") and obj.signing_info is None:
            obj.signing_info = {}
        if hasattr(obj, "sdk_info") and obj.sdk_info is None:
            obj.sdk_info = {}

    async def refresh(self, obj):
        # Ensure fields are populated after commit
        self._populate_auto_fields(obj)

    async def delete(self, obj):
        pass


async def override_get_db() -> AsyncGenerator[MockAsyncSession, None]:
    """Override database dependency for tests."""
    session = MockAsyncSession()
    try:
        yield session
    finally:
        pass


# Override the dependency
app.dependency_overrides[get_db] = override_get_db


@pytest.fixture
def client() -> Generator[TestClient, None, None]:
    """Get a test client for synchronous tests."""
    with TestClient(app) as c:
        yield c


@pytest_asyncio.fixture
async def async_client() -> AsyncGenerator[AsyncClient, None]:
    """Get an async test client."""
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as ac:
        yield ac


# ============================================================================
# Mock Fixtures
# ============================================================================


@pytest.fixture
def mock_docker_executor():
    """Mock Docker executor for analyzer tests."""
    mock = MagicMock()
    mock.run_container = AsyncMock(return_value={"status": "success", "output": "{}"})
    return mock


@pytest.fixture
def mock_device_manager():
    """Mock device manager for device tests."""
    mock = MagicMock()
    mock.list_android_devices = MagicMock(return_value=[
        {"serial": "emulator-5554", "status": "device", "model": "sdk_gphone64_x86_64"}
    ])
    mock.list_ios_devices = MagicMock(return_value=[])
    return mock


@pytest.fixture
def mock_frida_service():
    """Mock Frida service for dynamic analysis tests."""
    mock = MagicMock()
    mock.inject_script = AsyncMock(return_value={"session_id": "test-session-123"})
    mock.detach_session = AsyncMock(return_value=True)
    return mock


# ============================================================================
# Sample Data Fixtures
# ============================================================================


@pytest.fixture
def sample_app_data():
    """Sample mobile app data for testing."""
    return {
        "app_id": "test-app-123",
        "package_name": "com.example.testapp",
        "app_name": "Test App",
        "version_name": "1.0.0",
        "version_code": 1,
        "platform": "android",
        "status": "ready",
        "file_hash_sha256": "abc123def456",
    }


@pytest.fixture
def sample_finding_data():
    """Sample finding data for testing."""
    return {
        "finding_id": "finding-123",
        "app_id": "test-app-123",
        "tool": "manifest_analyzer",
        "platform": "android",
        "severity": "high",
        "status": "open",
        "category": "Insecure Configuration",
        "title": "Debuggable Application",
        "description": "The application is marked as debuggable in the manifest.",
        "impact": "Attackers can attach debuggers to inspect application memory.",
        "remediation": "Set android:debuggable to false in release builds.",
        "owasp_masvs_category": "MASVS-RESILIENCE",
        "cwe_id": "CWE-489",
    }


@pytest.fixture
def sample_scan_data():
    """Sample scan data for testing."""
    return {
        "scan_id": "scan-123",
        "app_id": "test-app-123",
        "scan_type": "static",
        "status": "pending",
        "progress": 0,
        "analyzers_enabled": ["manifest_analyzer", "secret_scanner"],
    }


@pytest.fixture
def sample_device_data():
    """Sample device data for testing."""
    return {
        "device_id": "device-123",
        "device_type": "emulator",
        "platform": "android",
        "device_name": "Pixel 6 API 33",
        "model": "sdk_gphone64_x86_64",
        "os_version": "13",
        "status": "connected",
        "is_rooted": True,
    }


@pytest.fixture
def sample_secret_data():
    """Sample secret data for testing."""
    return {
        "secret_id": "secret-123",
        "app_id": "test-app-123",
        "secret_type": "api_key",
        "provider": "google",
        "value": "AIzaSyA1234567890abcdefg",
        "file_path": "res/values/strings.xml",
        "line_number": 42,
        "validation_status": "unknown",
    }


@pytest.fixture
def sample_android_manifest():
    """Sample AndroidManifest.xml content."""
    return """<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.testapp"
    android:versionCode="1"
    android:versionName="1.0.0">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.CAMERA" />

    <application
        android:allowBackup="true"
        android:debuggable="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:networkSecurityConfig="@xml/network_security_config"
        android:usesCleartextTraffic="true">

        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <activity
            android:name=".DeepLinkActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
                <data android:scheme="testapp" android:host="open" />
            </intent-filter>
        </activity>

        <provider
            android:name=".DataProvider"
            android:authorities="com.example.testapp.provider"
            android:exported="true" />

        <receiver
            android:name=".BootReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>

    </application>
</manifest>"""


def create_test_archive(tmp_path, files: dict[str, str | bytes], suffix: str = ".apk") -> str:
    """Create a test zip archive with given file contents.

    Args:
        tmp_path: pytest tmp_path fixture
        files: Dict mapping archive-relative paths to content (str or bytes)
        suffix: File extension for the archive (default: .apk)

    Returns:
        Absolute path to the created archive
    """
    import zipfile

    archive_path = tmp_path / f"test_app{suffix}"
    with zipfile.ZipFile(archive_path, "w") as zf:
        for path, content in files.items():
            if isinstance(content, str):
                content = content.encode("utf-8")
            zf.writestr(path, content)
    return str(archive_path)


def make_mock_app(
    tmp_path,
    files: dict[str, str | bytes] | None = None,
    platform: str = "android",
    package_name: str = "com.example.testapp",
    suffix: str = ".apk",
) -> MobileApp:
    """Create a MobileApp instance with an optional test archive.

    Args:
        tmp_path: pytest tmp_path fixture
        files: Optional dict of archive files to create
        platform: App platform (android/ios)
        package_name: App package name
        suffix: Archive suffix

    Returns:
        MobileApp instance with file_path set
    """
    from api.models.database import MobileApp as MobileAppModel

    file_path = None
    if files is not None:
        file_path = create_test_archive(tmp_path, files, suffix)

    app = MobileAppModel(
        app_id=f"test-{uuid4().hex[:8]}",
        package_name=package_name,
        app_name="Test App",
        version_name="1.0.0",
        version_code=1,
        platform=platform,
        status="ready",
        file_hash_sha256="test_hash",
        file_path=file_path,
    )
    return app


@pytest.fixture
def sample_ios_info_plist():
    """Sample iOS Info.plist content as dict."""
    return {
        "CFBundleIdentifier": "com.example.testapp",
        "CFBundleName": "TestApp",
        "CFBundleDisplayName": "Test App",
        "CFBundleShortVersionString": "1.0.0",
        "CFBundleVersion": "1",
        "CFBundleExecutable": "TestApp",
        "MinimumOSVersion": "14.0",
        "UIDeviceFamily": [1, 2],
        "NSAppTransportSecurity": {
            "NSAllowsArbitraryLoads": True,
        },
        "CFBundleURLTypes": [
            {
                "CFBundleURLName": "com.example.testapp",
                "CFBundleURLSchemes": ["testapp", "fb12345"],
            }
        ],
        "NSCameraUsageDescription": "We need camera access",
        "NSLocationWhenInUseUsageDescription": "We need your location",
    }
